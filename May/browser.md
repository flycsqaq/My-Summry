# 浏览器
>主要参考《浏览器的工作原理》

>浏览器的主要功能是将用户选择的web资源呈现出来。 --《浏览器的工作原理》
## 主要构成
浏览器或者说呈现web资源需要众多模块相互配合。既然呈现的是用户选择的web资源。那么必然需要用户界面供用户操作;用户输入url获取资源，必然需要网络;呈现资源，需要一种契约来约束资源的语言，主要是HTML、CSS与JavaScript，其中HTML与CSS是由渲染引擎解析的，而JavaScript则是由JS解析器解析的;除此之外，还需要UI后端将资源绘制出来来吸引用户;此外客户端还需要保存本地数据的功能，因此需要数据存储模块，渲染引擎无法直接访问数据存储模块，因此需要中间层作桥梁，那便是浏览器引擎，除此浏览器引擎还提供了用其他语言编写插件访问其他模块的功能。
1. 用户界面
2. 网络
3. 渲染引擎
4. JS解析器
5. UI后端
6. 数据存储
7. 浏览器引擎

# 渲染引擎的工作
渲染引擎是单线程工作的。但也有其他线程辅助工作。预解析，即在执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这可以并行加载资源，从而提高整体速度。预解析只解析外部资源的引用，并不改变DOM树;即只发送HTTP请求，```ansys```则会异步获取资源，在脚本获取后使用另一个线程会执行脚本。其他的工作都由主流程完成。
## 渲染主流程
渲染主流程主要由以下四个步骤构成：
| 名称 | 输入 | 输出 |
|:--:|:----:|:----:|
|构建DOM树|HTML文档|DOM树|
|构建render树|DOM树/style rules|render树|
|布局|render树|盒子|
|绘制|render树|视图|
## 解析
无论是构建DOM树还是render树，都要对文档进行解析。解析将一个文档按照词汇表与语法转化为具有一定意义的结构--解析树。
1. 词汇表一般都由正则表达式表达;
2. 语法则是上下文无关文法，即具有严格的定义的语言(很模糊，具体请看原文的第三章)。
## 构建DOM树
将源码先解析成解析树，再将该树转化为DOM树。
### HTML解析器
HTML不能用简单的上下文无关文法定义。因为其需要有一定的容错以及一定的省略，是一种灵活的语法。
### 状态机
用标记来描述某个对象的状态。并在转变为某个状态时自动执行一些代码。事实上，web编程的事件模型也是基于状态机的。
### 符号识别算法
1. Data State
2. Tag open state
3. Close tag open state
4. Tag name
### 树的构建算法
1. initial mode
2. before html
3. before head
4. in head
5. after head
6. in body
7. after body
8. after after body
### 解析结束时的处理
```defer```标记的脚本将被执行，触发load事件。

## 脚本
解析到script标签，如果是内联脚本，则立即执行;如果是外引，会发送HTTP请求，请求资源(同步)，阻塞文档解析，然后执行脚本。```ansys```则会异步获取资源，在脚本获取后使用另一个线程会执行脚本。因此，与DOM无关并不依赖其他脚本的脚本可以异步执行。
### 样式表
样式表不改变DOM树，因此HTML文档在解析时不会阻塞。但脚本可能会在文档解析时请求样式信息，但此时样式可能还未加载和解析，未构建render树，因此会造成脚本阻塞。

## 构建render树
考虑最简单的情况，DOM构建完毕后浏览器开始构建渲染树，不考虑异步情况。渲染对象继承自DOM节点及渲染对象基类。
### 样式计算
因样式表结构非常大，因此保存所有信息会带来内存问题；同时为每个元素找到匹配的规则也有很大的工作量；需要对级联定义规则层次。<br>
共享样式数据及构建规则树定义级联顺序可以解决上述问题。
### 布局
布局是指渲染对象被添加到render树中时计算位置及大小的过程。每个渲染对象都知道布局、绘制及children。
### Dirty bit系统
因为全局和增量layout会造成全局重新布局，会引起性能上的问题，因此需要避免。即更改display,font-size;
### 布局过程
1. parent渲染对象绝对自己的宽度，
2. 读取children
3. 使用children的累计高度
### inline/block
1. inline渲染对象，width/height/margin-top/margin-bottom无效
2. block渲染对象margin叠加
### 绘制
1. 背景色
2. 背景图
3. border
4. children
5. outline
